name: Pipeline CI/CD

on:
  push:
    branches:
      - main

env:
  DEPLOY_HOST: 10.10.1.222
  DEPLOY_USER: root
  DEPLOY_PORT: 22
  PROJECT_DIR: /home/admin-ti/controle_material
  DOCKER_REGISTRY: 10.10.1.222:5000
  MYSQL_DATABASE: controle_material
  STACK_NAME: controle_material

jobs:
  build:
    name: Build and Push Images
    runs-on: self-hosted
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Build backend image
        run: |
          docker build -t ${{ env.DOCKER_REGISTRY }}/controle_material-backend:latest \
                       -t ${{ env.DOCKER_REGISTRY }}/controle_material-backend:${{ github.sha }} \
                       ./backend
          docker save -o backend-image.tar \
                      ${{ env.DOCKER_REGISTRY }}/controle_material-backend:latest \
                      ${{ env.DOCKER_REGISTRY }}/controle_material-backend:${{ github.sha }}

      - name: Build frontend image
        run: |
          docker build -t ${{ env.DOCKER_REGISTRY }}/controle_material-frontend:latest \
                       -t ${{ env.DOCKER_REGISTRY }}/controle_material-frontend:${{ github.sha }} \
                       ./frontend
          docker save -o frontend-image.tar \
                      ${{ env.DOCKER_REGISTRY }}/controle_material-frontend:latest \
                      ${{ env.DOCKER_REGISTRY }}/controle_material-frontend:${{ github.sha }}

      - name: Upload backend image artifact
        uses: actions/upload-artifact@v5
        with:
          name: backend-image
          path: backend-image.tar
          retention-days: 1

      - name: Upload frontend image artifact
        uses: actions/upload-artifact@v5
        with:
          name: frontend-image
          path: frontend-image.tar
          retention-days: 1

  deploy:
    name: Deploy to Swarm
    needs: build
    runs-on: self-hosted  # Runner no mesmo servidor do Swarm
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download backend image
        uses: actions/download-artifact@v4
        with:
          name: backend-image

      - name: Download frontend image
        uses: actions/download-artifact@v4
        with:
          name: frontend-image

      - name: Deploy Locally
        env:
          DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}
          STACK_NAME: ${{ env.STACK_NAME }}
        run: |
          echo "üì¶ Loading backend image..."
          docker load -i backend-image.tar

          echo "üì¶ Loading frontend image..."
          docker load -i frontend-image.tar

          echo "üîç Detecting service names..."
          # Detectar nome real dos servi√ßos (pode ser controle_material_backend ou controle_estoque_backend)
          BACKEND_SERVICE=$(docker service ls --format "{{.Name}}" | grep backend | head -n 1)
          FRONTEND_SERVICE=$(docker service ls --format "{{.Name}}" | grep frontend | head -n 1)
          
          if [ -z "$BACKEND_SERVICE" ] || [ -z "$FRONTEND_SERVICE" ]; then
            echo "‚ö†Ô∏è Services not found! Performing initial stack deployment..."
            echo ""
            echo "üìã Deploying stack from docker-compose.yml..."
            docker stack deploy -c docker-compose.yml ${{ env.STACK_NAME }}
            
            echo "‚è≥ Waiting for services to start..."
            sleep 20
            
            echo "‚úÖ Stack deployed successfully!"
            docker service ls | grep ${{ env.STACK_NAME }}
            
            echo ""
            echo "üéâ Initial deployment completed!"
            exit 0
          fi
          
          echo "‚úÖ Found services:"
          echo "  Backend: $BACKEND_SERVICE"
          echo "  Frontend: $FRONTEND_SERVICE"

          echo ""
          echo "üîÑ Updating Swarm services (zero downtime)..."
          
          # Atualizar backend com rolling update
          docker service update \
            --image ${{ env.DOCKER_REGISTRY }}/controle_material-backend:latest \
            --update-parallelism 1 \
            --update-delay 10s \
            --update-order start-first \
            "$BACKEND_SERVICE"
          
          echo "‚úÖ Backend update initiated"
          
          # Atualizar frontend com rolling update
          docker service update \
            --image ${{ env.DOCKER_REGISTRY }}/controle_material-frontend:latest \
            --update-parallelism 1 \
            --update-delay 10s \
            --update-order start-first \
            "$FRONTEND_SERVICE"
          
          echo "‚úÖ Frontend update initiated"

          echo ""
          echo "üßπ Cleaning up tar files..."
          rm -f backend-image.tar frontend-image.tar

          echo "‚è≥ Waiting for rollout to complete..."
          sleep 15

          echo ""
          echo "‚úÖ Service status:"
          docker service ls | grep -E "(backend|frontend)"
          
          echo ""
          echo "üìä Backend replicas:"
          docker service ps "$BACKEND_SERVICE" --filter "desired-state=running" --format "table {{.Name}}\t{{.CurrentState}}\t{{.Error}}" | head -n 5
          
          echo ""
          echo "üìä Frontend replicas:"
          docker service ps "$FRONTEND_SERVICE" --filter "desired-state=running" --format "table {{.Name}}\t{{.CurrentState}}\t{{.Error}}" | head -n 5

          # Verificar se h√° erros
          BACKEND_ERRORS=$(docker service ps "$BACKEND_SERVICE" --filter "desired-state=running" --format "{{.Error}}" | grep -v "^$" || true)
          FRONTEND_ERRORS=$(docker service ps "$FRONTEND_SERVICE" --filter "desired-state=running" --format "{{.Error}}" | grep -v "^$" || true)
          
          if [ -n "$BACKEND_ERRORS" ] || [ -n "$FRONTEND_ERRORS" ]; then
            echo ""
            echo "‚ùå Errors detected during deployment!"
            [ -n "$BACKEND_ERRORS" ] && echo "Backend errors: $BACKEND_ERRORS"
            [ -n "$FRONTEND_ERRORS" ] && echo "Frontend errors: $FRONTEND_ERRORS"
            exit 1
          fi

          echo ""
          echo "üéâ Deploy completed successfully with zero downtime!"
